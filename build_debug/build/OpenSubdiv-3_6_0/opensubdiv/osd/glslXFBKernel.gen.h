"//\n"
"//   Copyright 2013 Pixar\n"
"//\n"
"//   Licensed under the Apache License, Version 2.0 (the \"Apache License\")\n"
"//   with the following modification; you may not use this file except in\n"
"//   compliance with the Apache License and the following modification to it:\n"
"//   Section 6. Trademarks. is deleted and replaced with:\n"
"//\n"
"//   6. Trademarks. This License does not grant permission to use the trade\n"
"//      names, trademarks, service marks, or product names of the Licensor\n"
"//      and its affiliates, except as required to comply with Section 4(c) of\n"
"//      the License and to reproduce the content of the NOTICE file.\n"
"//\n"
"//   You may obtain a copy of the Apache License at\n"
"//\n"
"//       http://www.apache.org/licenses/LICENSE-2.0\n"
"//\n"
"//   Unless required by applicable law or agreed to in writing, software\n"
"//   distributed under the Apache License with the above modification is\n"
"//   distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n"
"//   KIND, either express or implied. See the Apache License for the specific\n"
"//   language governing permissions and limitations under the Apache License.\n"
"//\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"uniform samplerBuffer vertexBuffer;\n"
"uniform int srcOffset = 0;\n"
"out float outVertexBuffer[LENGTH];\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"struct Vertex {\n"
"    float vertexData[LENGTH];\n"
"};\n"
"\n"
"void clear(out Vertex v) {\n"
"    for (int i = 0; i < LENGTH; i++) {\n"
"        v.vertexData[i] = 0;\n"
"    }\n"
"}\n"
"\n"
"void addWithWeight(inout Vertex v, Vertex src, float weight) {\n"
"    for(int j = 0; j < LENGTH; j++) {\n"
"        v.vertexData[j] += weight * src.vertexData[j];\n"
"    }\n"
"}\n"
"\n"
"Vertex readVertex(int index) {\n"
"    Vertex v;\n"
"    int vertexIndex = srcOffset + index * SRC_STRIDE;\n"
"    for(int j = 0; j < LENGTH; j++) {\n"
"        v.vertexData[j] = texelFetch(vertexBuffer, vertexIndex+j).x;\n"
"    }\n"
"    return v;\n"
"}\n"
"\n"
"void writeVertex(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outVertexBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES) && "
"    defined(OPENSUBDIV_GLSL_XFB_INTERLEAVED_1ST_DERIVATIVE_BUFFERS)\n"
"out float outDeriv1Buffer[2*LENGTH];\n"
"\n"
"void writeDu(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDeriv1Buffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDeriv1Buffer[i+LENGTH] = v.vertexData[i];\n"
"    }\n"
"}\n"
"#elif defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES)\n"
"out float outDuBuffer[LENGTH];\n"
"out float outDvBuffer[LENGTH];\n"
"\n"
"void writeDu(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDuBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDvBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES) && "
"    defined(OPENSUBDIV_GLSL_XFB_INTERLEAVED_2ND_DERIVATIVE_BUFFERS)\n"
"out float outDeriv2Buffer[3*LENGTH];\n"
"\n"
"void writeDuu(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDeriv2Buffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDuv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDeriv2Buffer[i+LENGTH] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDvv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDeriv2Buffer[i+2*LENGTH] = v.vertexData[i];\n"
"    }\n"
"}\n"
"#elif defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES)\n"
"out float outDuuBuffer[LENGTH];\n"
"out float outDuvBuffer[LENGTH];\n"
"out float outDvvBuffer[LENGTH];\n"
"\n"
"void writeDuu(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDuuBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDuv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDuvBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"\n"
"void writeDvv(Vertex v) {\n"
"    for(int i = 0; i < LENGTH; i++) {\n"
"        outDvvBuffer[i] = v.vertexData[i];\n"
"    }\n"
"}\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_KERNEL_EVAL_STENCILS)\n"
"\n"
"uniform usamplerBuffer sizes;\n"
"uniform isamplerBuffer offsets;\n"
"uniform isamplerBuffer indices;\n"
"uniform samplerBuffer  weights;\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES)\n"
"uniform samplerBuffer  duWeights;\n"
"uniform samplerBuffer  dvWeights;\n"
"#endif\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES)\n"
"uniform samplerBuffer  duuWeights;\n"
"uniform samplerBuffer  duvWeights;\n"
"uniform samplerBuffer  dvvWeights;\n"
"#endif\n"
"\n"
"uniform int batchStart = 0;\n"
"uniform int batchEnd = 0;\n"
"\n"
"void main() {\n"
"    int current = gl_VertexID + batchStart;\n"
"\n"
"    if (current>=batchEnd) {\n"
"        return;\n"
"    }\n"
"\n"
"    Vertex dst, du, dv, duu, duv, dvv;\n"
"    clear(dst);\n"
"    clear(du);\n"
"    clear(dv);\n"
"    clear(duu);\n"
"    clear(duv);\n"
"    clear(dvv);\n"
"\n"
"    int offset = texelFetch(offsets, current).x;\n"
"    uint size = texelFetch(sizes, current).x;\n"
"\n"
"    for (int stencil=0; stencil<size; ++stencil) {\n"
"        int index = texelFetch(indices, offset+stencil).x;\n"
"        float weight = texelFetch(weights, offset+stencil).x;\n"
"        addWithWeight(dst, readVertex( index ), weight);\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES)\n"
"        float duWeight = texelFetch(duWeights, offset+stencil).x;\n"
"        float dvWeight = texelFetch(dvWeights, offset+stencil).x;\n"
"        addWithWeight(du,  readVertex(index), duWeight);\n"
"        addWithWeight(dv,  readVertex(index), dvWeight);\n"
"#endif\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES)\n"
"        float duuWeight = texelFetch(duuWeights, offset+stencil).x;\n"
"        float duvWeight = texelFetch(duvWeights, offset+stencil).x;\n"
"        float dvvWeight = texelFetch(dvvWeights, offset+stencil).x;\n"
"        addWithWeight(duu,  readVertex(index), duuWeight);\n"
"        addWithWeight(duv,  readVertex(index), duvWeight);\n"
"        addWithWeight(dvv,  readVertex(index), dvvWeight);\n"
"#endif\n"
"    }\n"
"    writeVertex(dst);\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES)\n"
"    writeDu(du);\n"
"    writeDv(dv);\n"
"#endif\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES)\n"
"    writeDuu(duu);\n"
"    writeDuv(duv);\n"
"    writeDvv(dvv);\n"
"#endif\n"
"}\n"
"\n"
"#endif\n"
"\n"
"//------------------------------------------------------------------------------\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_KERNEL_EVAL_PATCHES)\n"
"\n"
"layout (location = 0) in ivec3 patchHandles;\n"
"layout (location = 1) in vec2  patchCoords;\n"
"\n"
"layout (std140) uniform PatchArrays {\n"
"    OsdPatchArray patchArrays[2];\n"
"};\n"
"uniform isamplerBuffer patchParamBuffer;\n"
"uniform isamplerBuffer patchIndexBuffer;\n"
"\n"
"OsdPatchArray GetPatchArray(int arrayIndex) {\n"
"    return patchArrays[arrayIndex];\n"
"}\n"
"\n"
"OsdPatchParam GetPatchParam(int patchIndex) {\n"
"    ivec3 patchParamBits = texelFetch(patchParamBuffer, patchIndex).xyz;\n"
"    return OsdPatchParamInit(patchParamBits.x, patchParamBits.y, patchParamBits.z);\n"
"}\n"
"\n"
"void main() {\n"
"    int current = gl_VertexID;\n"
"\n"
"    ivec3 handle = patchHandles;\n"
"    int arrayIndex = handle.x;\n"
"    int patchIndex = handle.y;\n"
"\n"
"    vec2 coord = patchCoords;\n"
"\n"
"    OsdPatchArray array = GetPatchArray(arrayIndex);\n"
"    OsdPatchParam param = GetPatchParam(patchIndex);\n"
"\n"
"    int patchType = OsdPatchParamIsRegular(param) ? array.regDesc : array.desc;\n"
"\n"
"    float wP[20], wDu[20], wDv[20], wDuu[20], wDuv[20], wDvv[20];\n"
"    int nPoints = OsdEvaluatePatchBasis(patchType, param,\n"
"        coord.x, coord.y, wP, wDu, wDv, wDuu, wDuv, wDvv);\n"
"\n"
"    Vertex dst, du, dv, duu, duv, dvv;\n"
"    clear(dst);\n"
"    clear(du);\n"
"    clear(dv);\n"
"    clear(duu);\n"
"    clear(duv);\n"
"    clear(dvv);\n"
"\n"
"    int indexBase = array.indexBase + array.stride *\n"
"                (patchIndex - array.primitiveIdBase);\n"
"\n"
"    for (int cv = 0; cv < nPoints; ++cv) {\n"
"        int index = texelFetch(patchIndexBuffer, indexBase + cv).x;\n"
"        addWithWeight(dst, readVertex(index), wP[cv]);\n"
"        addWithWeight(du,  readVertex(index), wDu[cv]);\n"
"        addWithWeight(dv,  readVertex(index), wDv[cv]);\n"
"        addWithWeight(duu, readVertex(index), wDuu[cv]);\n"
"        addWithWeight(duv, readVertex(index), wDuv[cv]);\n"
"        addWithWeight(dvv, readVertex(index), wDvv[cv]);\n"
"    }\n"
"\n"
"    writeVertex(dst);\n"
"\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_1ST_DERIVATIVES)\n"
"    writeDu(du);\n"
"    writeDv(dv);\n"
"#endif\n"
"#if defined(OPENSUBDIV_GLSL_XFB_USE_2ND_DERIVATIVES)\n"
"    writeDuu(duu);\n"
"    writeDuv(duv);\n"
"    writeDvv(dvv);\n"
"#endif\n"
"}\n"
"\n"
"#endif\n"
"\n"
"\n"
