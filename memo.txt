○バイナリパスの取得処理を実装
{
	"test" : 1,
	"test_list" : [
		"test_2" : "test_value",
		"test_3" : {
			"x" : 1,
			"y" : 1,
			"z" : 1,
		}
	}
}

std::string const &fileName
std::ifstream fin(fileName.c_str());
if (!fin.is_open())

○バイナリから読み込む処理を実装
・GetRootAsを調査
・Tutorialの例を再現する

●https://zenn.dev/hikarin/articles/3346f9bb2ae2302a1a80
#include <iostream>
#include <fstream>
using namespace std;

#include "monster_generated.h"
using namespace MyGame::Sample;

int main() {

	// ファイル読み込み
 	ifstream fin("monster.bin", ios::in | ios::binary);
    if (!fin) {
        return 1;
    }
	auto begin = fin.tellg();
	fin.seekg(0, fin.end);
	auto end = fin.tellg();
	fin.clear();
	fin.seekg(0, fin.beg);
	auto len = end - begin;
	auto buf = new char[len + 1];
	fin.read(buf, len);
    fin.close();

	// バッファ設定
	auto monster = GetMonster((uint8_t*)buf);

	// hp, mana, name
	printf("hp: %d\n", monster->hp());
	printf("mana: %d\n", monster->mana());
	printf("name: %s\n", monster->name()->c_str());

	// inventory
	printf("inventory: [");
	for (auto val: *monster->inventory()) {
		printf("%d, ", val);
	}
	printf("\b\b]\n");

	// weapons
	printf("weapons: [");
	for (auto wp: *monster->weapons()) {
		printf("{\n");
		printf("\tname: %s\n", wp->name()->c_str());
		printf("\tdamage: %d\n", wp->damage());
		printf("}, ");
	}
	printf("\b\b]\n");

	// equipped
	auto union_type = monster->equipped_type();
	if (union_type == Equipment_Weapon) {
		// Requires `static_cast` to type `const Weapon*`.
		auto weapon = static_cast<const Weapon*>(monster->equipped());
		printf("equipped: Weapon{\n");
		printf("\tname: %s\n", weapon->name()->c_str());
		printf("\tdamage: %d\n", weapon->damage());
		printf("}\n");
	}

	delete[] buf;
}

●ChatGPT
#include <fstream>
#include <vector>
#include <iostream>
#include "example_generated.h"

int main() {
    // バイナリデータをファイルから読み込む
    std::ifstream infile("data.bfbs", std::ios::binary);
    if (!infile) {
        std::cerr << "Failed to open file!" << std::endl;
        return -1;
    }

    // ファイルの終端を取得してサイズを取得
    infile.seekg(0, std::ios::end);
    size_t fileSize = infile.tellg();
    infile.seekg(0, std::ios::beg);

    // バッファを確保して読み込む
    std::vector<uint8_t> buffer(fileSize);
    infile.read(reinterpret_cast<char*>(buffer.data()), fileSize);

    // ---- バイナリからルートを取得 ----
    const MyData* data = flatbuffers::GetRoot<MyData>(buffer.data());

    // ---- データを操作 ----
    if (data) {
        std::cout << "ID: " << data->id() << std::endl;
        std::cout << "Name: " << data->name()->c_str() << std::endl;
    } else {
        std::cerr << "Invalid FlatBuffer data!" << std::endl;
    }

    return 0;
}

○USDの構築処理のサンプル処理を実装
SdfLayerRefPtr UsdObjTranslateObjToUsd(const UsdObjStream &objStream)
{
    // Create the layer to populate.
    SdfLayerRefPtr layer = SdfLayer::CreateAnonymous(".usda");

    // Create a UsdStage with that root layer.
    UsdStageRefPtr stage = UsdStage::Open(layer);

	// Create a mesh for the group.
	UsdGeomMesh mesh =　UsdGeomMesh::Define(stage, SdfPath("/" + group.name));

	// Populate the mesh data from the obj data.  This is not a very smart
	// importer.  We throw all the verts onto everything for simplicity.  If
	// this was a proper obj importer, it would reindex verts per-group.
	mesh.GetPointsAttr().Set(usdPoints);

	VtArray<int> faceVertexCounts, faceVertexIndices, faceUVIndices;
	for (const auto& face : group.faces) {
		faceVertexCounts.push_back(face.size());
		for (int p = face.pointsBegin; p != face.pointsEnd; ++p) {
			faceVertexIndices.push_back(objPoints[p].vertIndex);
			if (objPoints[p].uvIndex >= 0) {
				faceUVIndices.push_back(objPoints[p].uvIndex);
			}
		}
	}

	// Now set the attributes.
	mesh.GetFaceVertexCountsAttr().Set(faceVertexCounts);
	mesh.GetFaceVertexIndicesAttr().Set(faceVertexIndices);

	// Create a primvar for the UVs if stored in the obj data. Note that
	// it's valid in this layer for the UV mapping to not be fully defined
	// in the obj data. For example, this layer may just provide the texture
	// coordinates and another layer the indexing, or vice versa.
	if (!usdUVs.empty() || !faceUVIndices.empty()) {
		UsdGeomPrimvar uvPrimVar = UsdGeomPrimvarsAPI(mesh).CreatePrimvar(
		TfToken("uv"), SdfValueTypeNames->TexCoord2fArray,
		UsdGeomTokens->faceVarying);
		if (!usdUVs.empty()) {
			uvPrimVar.GetAttr().Set(usdUVs);
		}
		if (!faceUVIndices.empty()) {
			uvPrimVar.CreateIndicesAttr().Set(faceUVIndices); // indexed
		}
	}

	// Set extent.
	mesh.GetExtentAttr().Set(extentArray);
    }

    return layer;
}